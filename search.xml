<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[去除html带标签正则]]></title>
      <url>http://www.zhouhy.me/2017/07/03/%E5%8E%BB%E9%99%A4html%E5%B8%A6%E6%A0%87%E7%AD%BE%E6%AD%A3%E5%88%99/</url>
      <content type="html"><![CDATA[<pre><code>re=/&lt;[^&lt;&gt;]+&gt;/g
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git Bash记住用户名密码]]></title>
      <url>http://www.zhouhy.me/2017/06/30/Git-Bash%E8%AE%B0%E4%BD%8F%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>Git form windows 如何记住用户名密码<br>每次用命令push代码的时候都需要输入用户名和密码，实在是太麻烦了，百度一下，找到解决办法：<br>先创建存储用户名密码的文件，在home文件夹，一般是在C:\Documents and Settings\Administrator下建立文件.git-credentials(windows下不允许直接创建以.开关的文件，所以有一个小技巧：先创建一个文件名为git-credentials的文件，然后进入git bash)使用命令：<br>    mv git - - credentials .git-credentials</p>
<p>用记事本打开这个文件输入，如果用户名中有@，那么使用%代替：</p>
<pre><code>https://{{username}}:{{password}}@gitgub.com
</code></pre><p>例：<a href="https://zhouhy:123456@github.com" target="_blank" rel="external">https://zhouhy:123456@github.com</a><br>保存；</p>
<p>进入git bash ，然后输入：</p>
<pre><code>git config - -global credential.helper store
</code></pre><p>执行完后去查看 C:\Documents and Settings\Administrator.gitconfig 这个文件，发现多了一项：</p>
<pre><code>[credential] 
helper = store
</code></pre><p>就成功了。</p>
<p>然后要重开 git bash 窗口，再push就不用输入用户名密码</p>
]]></content>
      
        
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5新增标签属性]]></title>
      <url>http://www.zhouhy.me/2017/06/13/HTML5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<ol>
<li><p>contextmenu:右键菜单</p>
<pre><code>&lt;div id=&quot;div1&quot; style=&quot;height:50px; background: lightgreen;&quot; contextmenu=&quot;menuShare&quot;&gt;&lt;/div&gt;
&lt;menu id=&quot;menuShare&quot; type=&quot;context&quot;&gt;
    &lt;menuitem label=&quot;分享到QQ空间&quot; onclick=&quot;alert(&apos;QQ&apos;);&quot;&gt;&lt;/menuitem&gt;
    &lt;menuitem label=&quot;分享到朋友圈&quot; onclick=&quot;alert(&apos;朋友圈&apos;);&quot;&gt;&lt;/menuitem&gt;
    &lt;menuitem label=&quot;分享到微博&quot; onclick=&quot;alert(&apos;微博&apos;);&quot;&gt;&lt;/menuitem&gt;
&lt;/menu&gt;
</code></pre></li>
<li><p>menu:定义菜单<br>menu属性：type：菜单类型属性，有三个值<br> 1) context：上下文<br> 2) toolbar:工具栏<br> 3) list:列表<br> menu内部还可以嵌入一个菜单项，即：menuitem<br> menuitem属性：</p>
<pre><code>label：菜单项显示的名称
icon:在菜单项左侧显示的图标
onclick：点击菜单项触发的事件
</code></pre></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VUE路由懒加载]]></title>
      <url>http://www.zhouhy.me/2017/06/12/VUE%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>当打包构建应用时，Javascript包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更高效了。</p>
<p>结合Vue的异步组件和webpack的code spiltting feature，轻松实现路由组件的懒加载。</p>
<p>我们要做的就是把路由对应的组件定义成异步组件：</p>
<pre><code>const Foo = resolve =&gt; {
    //require.ensure是webpack的特殊语法，用来设置code-split point
    //（代码分块）
    require.ensure([&apos;./Foo.vue&apos;],()=&gt;{
        resolve(require(&apos;./Foo.vue));
    })
}
</code></pre><p>这里还有另外一种代码分块的语法，使用AMD风格的require，于是就更简单了：</p>
<pre><code>const Foo = resolve =&gt; require([&apos;./Foo.vue&apos;],resovle);
</code></pre><p>不需要改变任何路由配置，跟之前一样使用Foo:</p>
<pre><code>const router = new VueRouter({
    routes:[
        {path: &apos;/foo&apos;,component:Foo}
    ]
})
</code></pre><h1 id="把组件按组分块"><a href="#把组件按组分块" class="headerlink" title="把组件按组分块"></a>把组件按组分块</h1><p>有时候我们想把某个路由下的所有组件都打包在同个异步chunk中，只需要给chunk命名，提供requrie.ensure，第三个参数作为chunk的名称：</p>
<pre><code>const Foo = r =&gt; require.ensure([],()=&gt;r(require(&apos;./Foo.vue&apos;)),&apos;group-foo&apos;);
const Bar = r =&gt; require.ensure([],()=&gt;r(require(&apos;./Bar.vue&apos;)),&apos;group-foo&apos;);
const Baz = r =&gt; require.ensure([],()=&gt;r(require(&apos;./Baz.vue&apos;)),&apos;group-foo&apos;);
</code></pre><p>webpack将相同chunk下的所有异步模块打包到一个异步块里面–这也意味着我们无须明确列出require.ensure的依赖（传空数组就行）。</p>
<p>转自：<a href="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html" title="https://router.vuejs.org/zh-cn/advanced/lazy-loading.html" target="_blank" rel="external">https://router.vuejs.org/zh-cn/advanced/lazy-loading.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> VUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue 报错Cannot assign to read only property 'exports' of object '#<Object>']]></title>
      <url>http://www.zhouhy.me/2017/06/01/Vue-%E6%8A%A5%E9%94%99Cannot-assign-to-read-only-property-exports-of-object-Object/</url>
      <content type="html"><![CDATA[<p>今天在项目里遇到一个错误，<br>    <code>Uncaught TypeError: Cannot assign to read only property &#39;exports&#39; of object &#39;#Object&#39; at Object.anonymous</code></p>
<p>网上搜了一下，是因为webpack中，不允许混用import 和 module.exports，但是可以混用require和export.<br>最终解决方法是统一改成ES6写法.</p>
]]></content>
      
        
        <tags>
            
            <tag> VUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令速查表]]></title>
      <url>http://www.zhouhy.me/2017/05/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      <content type="html"><![CDATA[<pre><code>master: 默认开发分支            HEAD：默认开发分支 
origin: 默认远程版本库        HEAD^:HEAD的父提交
</code></pre><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><pre><code>$ git clone &lt;url&gt;        #克隆远程版本库
$ git init                #初使化本地版本库
</code></pre><h2 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h2><pre><code>$ git status            #查看状态
$ git diff                #查看变更内容
$ git add .                #跟踪所有改动过的文件
$ git add &lt;file&gt;        #跟踪指定的文件
$ git mv &lt;old&gt; &lt;new&gt;    #文件改名
$ git rm &lt;file&gt;            #删除文件
$ git rm --cached &lt;file&gt;    #停止跟踪文件但不删除
$ git commit -m &quot;commit message&quot;    #提交更新文件
$ git commit --amend        #修改最后一次提交
</code></pre><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><pre><code>$ git log        #查看提交历史
$ git log -p &lt;file&gt;        #查看指定文件的指定历史
$ git blame &lt;file&gt;        #以列表方式查看指定文件的提交历史
</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><pre><code>$ git reset    --hard HEAD        #撤销工作目录中所有未提交文件的修改内容
$ git checkout HEAD &lt;file&gt;    #撤销指定的未提交文件的修改内容
$ git revert &lt;commit&gt;        #撤消指定的提交
</code></pre><h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><pre><code>$ git branch        #显示所有本地分支
$ git checkout &lt;branch/tag&gt;    #切换到指定分支或标签
$ git branch &lt;new branch&gt;    #创建新分支
$ git branch -d &lt;branch&gt;        #删除本地分支
$ git tag    #列出所有本地标签
$ git tag &lt;tagname&gt;        #基于最新提交创建标签
$ git -d &lt;tagname&gt;        #删除标签
</code></pre><h2 id="合并与衍合"><a href="#合并与衍合" class="headerlink" title="合并与衍合"></a>合并与衍合</h2><pre><code>$ git merge &lt;branch&gt;    #合并指定分支到当前分支
$ git rebase &lt;branch&gt;    #衍合指定分支到当前分支
</code></pre><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><pre><code>$ git remote -v            #查看远程版本库信息
$ git remote show &lt;remote&gt;        #查看指定远程版本库信息
$ git remote add &lt;remote&gt; &lt;url&gt;        #添加远程版本库
$ git fetch &lt;remote&gt;        #从远程库获取代码
$ git pull &lt;remote&gt; &lt;branch&gt;        #下载代码及快速合并
$ git push &lt;remote&gt; &lt;branch&gt;        #上传代码及快速合并
$ git push &lt;remote&gt; :&lt;branch/tag-name&gt;        #删除远程分支或标签
$ git push --tags        #上传所有标签
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js开发需要注意的问题(后期陆续更新)]]></title>
      <url>http://www.zhouhy.me/2017/04/25/Node-js%E5%BC%80%E5%8F%91%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<ol>
<li>Node.js项目，文件夹所在路径，一定不能有中文字符</li>
<li>node.js的项目文件一定要用utf-8编码格式，否则文件内容里的中文等双字节会出问题</li>
<li>json文件里不支持注释，任何格式的注释都不支持，如：// /<em> </em>/ <!-- --></li>
<li><p>node.js没有web.config文件，可以用一个json对象代替，比如在根目录下添加一个settings.js文件：</p>
<pre><code>module.exports = {
    abc:123456,
    def:&apos;www.zhouhy.me&apos;
}
</code></pre></li>
</ol>
<p>   调用方法：</p>
<pre><code>var settings = require(&apos;./settings&apos;);
console.log(settins.def);
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> Node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js中日志管理模块使用]]></title>
      <url>http://www.zhouhy.me/2017/04/25/Node-js%E4%B8%AD%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>在开发过程中，日志记录是必不可少的，尤其是生产系统中经常无法调试，日志就成了重要的调试信息来源。<br>Node.js的日志模块是log4js,源码：<a href="https://github.com/nomiddlename/log4js-node" title="https://github.com/nomiddlename/log4js-node" target="_blank" rel="external">https://github.com/nomiddlename/log4js-node</a></p>
<p>项目引用：npm install log4js</p>
<p>1.配置</p>
<pre><code>log4js.configure({
appenders:[{
    {type:&quot;console&quot;,&quot;category&quot;:&quot;console&quot;},//将日志输出到控制台，方便我们在开发时看到日志信息
    {
        &quot;type&quot;:&quot;dateFile&quot;,//日志文件类型，可以使用日期作为文件名的点位符
        &quot;filename&quot;:&quot;E:/website/logs/&quot;,//日志文件名，可以设置相对路径或绝对路径
        &quot;pattern&quot;:&quot;debug/yyyyMMddhh.txt&quot;，//占们符，紧跟filename后
        &quot;absolute&quot;:true,//文件名是否绝对路径
        &quot;alwaysIncludePattern&quot;:true，//文件名是否包含占位符
        &quot;category&quot;:&quot;logInfo&quot;//记录器名
    }
}]
})
</code></pre><p>pattern 可以使用占位符说明，不属于下列占位符格式，均原样输入文件名：<br>yy    两位年份<br>yyyy  四位年份<br>MM    两位月份<br>dd    两位日期<br>hh    两位的小时数，按24小时算<br>mm    两位的分数<br>ss    两位的秒数</p>
<p>2.代码调用</p>
<pre><code>var logger = require(&apos;./utils/logger&apos;);
logger.info(&apos;记录一下日志&apos;);
</code></pre><p>输出的log有六个level,每个level输出到终端时会使用不同的颜色，分别是：<br>trace：    蓝色<br>debug:    青色<br>info:    绿色<br>warn:    黄色<br>error:    红色<br>fatal:    粉色</p>
]]></content>
      
        
        <tags>
            
            <tag> Node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WebStorm无法显示文件夹目录]]></title>
      <url>http://www.zhouhy.me/2017/04/14/WebStorm%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>在做项目的时候webstorm打开项目时偶尔会遇到显示不了文件夹，出现这个原因主要是因为配置文件（.idea里的modules.xml）损坏。解决方法：</p>
<ol>
<li>删除webstorm的配置文件.idea</li>
<li>重新打开该项目</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 工具插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css处理浏览器输入框记住账号密码后的背景色]]></title>
      <url>http://www.zhouhy.me/2017/04/07/css%E5%A4%84%E7%90%86%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E6%A1%86%E8%AE%B0%E4%BD%8F%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E5%90%8E%E7%9A%84%E8%83%8C%E6%99%AF%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>在chrome里，记住密码后，通常会给用户名密码输入框渲染上一个背景色，在有些时候浏览器自动使用的渲染背景色会影响到系统本身的UI界面，以下是css处理方法：</p>
<pre><code>input:-webkit-autofill , textarea:-webkit-autofill, select:-webkit-autofill {  
-webkit-text-fill-color: #ededed !important;  
-webkit-box-shadow: 0 0 0px 1000px transparent  inset !important;  
background-color:transparent;  
background-image: none;  
 transition: background-color 50000s ease-in-out 0s; //背景色透明  生效时长  过渡效果  启用时延迟的时间  
}  
input {  
     background-color:transparent;  
}  
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在webstorm中使用autoprefixer]]></title>
      <url>http://www.zhouhy.me/2017/03/24/%E5%9C%A8webstorm%E4%B8%AD%E4%BD%BF%E7%94%A8autoprefixer/</url>
      <content type="html"><![CDATA[<h1 id="关于Autoprefixer"><a href="#关于Autoprefixer" class="headerlink" title="关于Autoprefixer"></a>关于Autoprefixer</h1><hr>
<p>Autoprefixer是一个后台处理程序，不像Sass以及Stylus之类的预处理器。它适用于普通的CSS，可以实现CSS3自动补全，也可以跟sass，less,及stylus集成，在CSS编译前或编译后运行。<br>附地址：<a href="https://github.com/postcss/autoprefixer" title="https://github.com/postcss/autoprefixer" target="_blank" rel="external">https://github.com/postcss/autoprefixer</a></p>
<p>当Autoprefixer添加前缀到css,还不会忘记修复语法差异。</p>
<pre><code>a{
     background : linear-gradient(to top, black, white);
     display : flex
}

::placeholder {
     color : #ccc
}
</code></pre><p>编译成：</p>
<pre><code>a {
    background : -webkit-linear-gradient(bottom, black, white);
    background : linear-gradient(to top, black, white);
    display : -webkit-box;
    display : -webkit-flex;
    display : -moz-box;
    display : -ms-flexbox;
    display : flex
}
:-ms-input-placeholder {
    color : #ccc
}
::-moz-placeholder {
    color : #ccc
}
::-webkit-input-placeholder {
    color : #ccc
}
::placeholder {
    color : #ccc
}
</code></pre><p>Autoprefixer 同样会清理过期的前缀，因此下面的代码：</p>
<pre><code>a {
    -webkit-border-radius : 5px;
    border-radius : 5px
}
</code></pre><p>编译成：</p>
<pre><code>a {
    border-radius : 5px
}
</code></pre><p>因为经过Autoprefixer处理，CSS将仅包含实际的浏览器前缀。<br><a id="more"></a></p>
<h2 id="具体安装和配置："><a href="#具体安装和配置：" class="headerlink" title="具体安装和配置："></a>具体安装和配置：</h2><p>所以尝试在Webstorm下搜索autoprefixer插件，无果。那就自己手动配置了一个。首先我考虑配置File Watchers，但是不习惯，原来在sublime text下用autoprefixer都是手动触发的，所以后面我配置了External Tools。</p>
<ol>
<li>首先当然是安装node.js;</li>
<li><p>安装Autoprefixer；</p>
<p> <code>npm install autoprefixer -g</code></p>
</li>
<li><p>安装postcss-cli</p>
<p> <code>npm install postcss-cli -g</code></p>
</li>
<li><p>配置External Tools<br>打开webstorm设置，工具集-外部工具，新增如图:<br><img src="/img/autoprefixer-1.jpg" alt=""></p>
<p> 填写具体配置:<br> <img src="/img/autoprefixer-2.jpg" alt=""></p>
<p> Program:填入你的postcss-cli 的PATH；<br> Parameters: -u autoprefixer -o $FileDir$/$FileName$  $FileDir$/$FileName$ ，你可以根据你自己的需要配置，具体参见<br> <a href="https://github.com/code42day/postcss-cli" title="https://github.com/code42day/postcss-cli" target="_blank" rel="external">https://github.com/code42day/postcss-cli</a><br> Working directory :$ProjectFileDir$</p>
<p> 配置好后，你可以在css，或sass文件中右键，就可以在右键菜单中看到External Tools – autoprefixer</p>
</li>
<li>设置快捷键<br>打开Webstorm设置，Preferences -&gt; Keymap ， 搜索External Tools ， 配置 autoprefixer即可。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 工具插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[content="IE=edge,chrome"=1详解]]></title>
      <url>http://www.zhouhy.me/2017/03/15/content-IE-edge-chrome-1%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</code><br>这个是IE的专用标记，来用指定IE浏览器去模拟某个特定版本的IE浏览器的渲染方式，以此来解决部分兼容问题，例如模拟IE7：<br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE7&quot; /&gt;</code><br>但另我好奇的是这个标记后面竟然出现了chrome这样的值，难道IE也可以模拟chrome了？<br>迅速搜索了一下，才明白原来不是微软增强了IE，而是google做了个外挂：google chrome frame(google内嵌浏览器框架GCF)。这个插件可以让用户的IE浏览器不变，但用户在浏览网页时，实际使用的是google chrome浏览器内核，而且支持IE6、7、8等多个版本的浏览器。<br>而上文提到的meta标记，则是在安装了GCF后，用来指定页面使用chrome内核来渲染。<br>GCF下载地址：<a href="http://code.google.com/intl/zh-CN/chrome/chromeframe/" target="_blank" rel="external">http://code.google.com/intl/zh-CN/chrome/chromeframe/</a><br>安装完成后，如果你想对某个页面使用GCF进行渲染，只需要在该页面的地址前加上gcf:即可，例如：<br>gcf:htt[://cooleep.com<br>但是如果想要在开发时指定页面默认，首页使用gcf进行渲染，如果未安装GCF再使用IE内核进行渲染，该如何进行呢？就是使用这个标记。</p>
<a id="more"></a>
<p>标记用法：<br>    阅读了chrome的开发文档(<a href="http://www.chromium.org/developers/how-tos/chrome-frame-getting-started" target="_blank" rel="external">http://www.chromium.org/developers/how-tos/chrome-frame-getting-started</a>),下面来简单了解一下这个标记的语法。<br>1.最基本的用法：在页面的头部加入：<br>    <code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;chrome=1&quot; /&gt;</code><br>用以声明当前页面使用chrome内核来渲染。复杂一些的就是本文一开始看到的那种方法，这样写可以达到的效果是如果安装了GCF，则使用GCF来渲染页面，如果未安装GCF，则使用最高版本的IE内核进行渲染。</p>
<p>2.通过修改HTTP头文件的方法来实现指定的页面使用GCF内核来渲染：<br>在http的头文件中加入以下信息：<br>X-UA-Compatible:chrome=1<br>在Apache服务器中，确保mod_headers和mod_setenvif文件可用，然后在httpd.conf中加入以下配置信息：<br>&lt; IfModule mod_setenvif.c&gt;</p>
<p>　　&lt; IfModule mod_headers.c&gt;</p>
<p>　　BrowserMatch chromeframe gcf</p>
<p>　　Header append X-UA-Compatible “chrome=1” env=gcf</p>
<p>在IIS7或者更高版本的服务器中，只需要修改web.config文件,添加如下信息即可即可:<br>&lt; configuration &gt;</p>
<p>　　&lt; system.webServer &gt;</p>
<p>　　&lt; httpProtocol &gt;</p>
<p>　　&lt; customHeaders &gt;</p>
<p>　　&lt; add name = “X-UA-Compatible” value = “chrome=1” /&gt;</p>
<p>　　</p>
<p>来自：<a href="http://blog.sina.com.cn/s/blog_a9e5c16d01011yly.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_a9e5c16d01011yly.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在hexo文章里插入本地图片]]></title>
      <url>http://www.zhouhy.me/2017/03/14/%E5%9C%A8hexo%E6%96%87%E7%AB%A0%E9%87%8C%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<p>用markdown写文章，插入图片的格式为：<code>![](){ImgCap}{/ImgCap}</code>,但图片路径从哪里来呢？<br>解决办法：<br>在/source文件夹下新建一个img文件夹，将图片放入img下面，图片链接地址为：/img/图片名称</p>
]]></content>
      
        
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在GIT中增加忽略文件夹与文件]]></title>
      <url>http://www.zhouhy.me/2017/03/14/%E5%9C%A8GIT%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<ol>
<li>在工作目录中右键选择<br><img src="/img/GIT.jpg" alt=""></li>
<li>输入touch .gitingore<br><br>这样在工作目录就生成了一个”.gitignore”文件</li>
<li>然后在“.gitignore”里面写上你要忽略的文件夹与文件即可。例如：<br> .DS_Store<br>.idea/<br>module/build/</li>
</ol>
<hr>
<p>注：如果文件已经提交到仓库了，那么就需要在缓存中将其清空：</p>
<ol>
<li>git rm -r - -cached “要取消的目录”</li>
<li>git commit -m “delete cached”<br><br>这样就OK了.</li>
</ol>
<p>PS:<strong>在项目的根目录（.git文件夹所在目录同级）建立.gitignore，在里面声明即可。</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS自带map方法]]></title>
      <url>http://www.zhouhy.me/2017/02/23/jsmap/</url>
      <content type="html"><![CDATA[<ul>
<li>方法概述：<br><br>map()  返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。</li>
<li>例子<br><br>1.在字符串中使用map<br><br> 在一个string上使用map获取字符串中每个字符所对应的ASCII码组成的数组：<br> <pre><code>var map = Array.prototype.map; 
var a = map.call(&quot;hello world&quot;,function(x){  
    return x.charCodeAt(0);  
});  
//a的值【72，101，108，108，111，32，87，111，114，108，100】
</code></pre>  <a id="more"></a>
2.易犯错误<br>通常情况下，map方法中的callback函数只需要接受一个参数（很多时候，自定义函数的形参只有一个），就是正在被遍历的数据元素本身。<br>但这并不意味着callback只传了一个参数(会传递3个参数)。这个思维惯性可能会让我们犯一个很容易犯的错误。<pre><code>&lt;pre&gt;
</code></pre>  //下面的语句返回什么呢：<br>  [“1”,”2”,”3”].map(parseInt);<br>  //你可能觉得会返回[1,2,3]<br>  //但实际结果是[1,NaN,NaN]<br>  //通常使用parseInt()时，只需要传递一个参数，但实际上parseInt()可以有两个参数，第二个参数是进制数，可以通过语句”console.log(parseInt.length)”来验证。<br>  //map方法在调用callback函数时，会给它传递三个参数：当前正在遍历的元素，元素索引，原数组本身。<br>  //第三个参数parseInt会自动忽略，但第二个不会，也就是parseInt把传过来的索引值当成进制数来使用，从而返回NaN。<br>  //应该使用如下的函数returnInt  <pre><code>function returnInt(el){  
    return parseInt(el,10);  
}  
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(returnInt);  
</code></pre>  <br><br><br><br>  文章引用：<a href="http://www.cnblogs.com/rocky-fang/p/5756733.html" target="_blank" rel="external">http://www.cnblogs.com/rocky-fang/p/5756733.html</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决iframe窗体丢失Session时登录窗口显示在子页面的问题]]></title>
      <url>http://www.zhouhy.me/2016/08/30/%E8%A7%A3%E5%86%B3iframe%E7%AA%97%E4%BD%93%E4%B8%A2%E5%A4%B1Session%E6%97%B6%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E5%9C%A8%E5%AD%90%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>若在项目是应该了iframe的朋友也许会碰到与我一样的问题。当窗体Sessoin丢失后登录的窗体在显示在iframe的主窗口中，这还不算，更糟的是登录后，又多出来了一个iframe。真有点伤脑筋。呵呵，今天特意找了一下资料，希望对大家有所帮助，解决方法其实很简单。代码如下：</p>
<pre><code>//在登录页面的onload中调用如下方法：
function ready(){
    if(top.location!=self.location)
    {
        top.location=self.location;
    }
}
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Web Uploader上传按钮失效]]></title>
      <url>http://www.zhouhy.me/2016/08/28/Web%20Uploader%E4%B8%8A%E4%BC%A0%E6%8C%89%E9%92%AE%E5%A4%B1%E6%95%88/</url>
      <content type="html"><![CDATA[<p>常见 flash 报错原因:</p>
<ol>
<li>flash 版本太低，请至少大于等于 11.4，低于此版本请提示更新 flash 版本</li>
<li><p>按钮或者他的父级被设置 display:none 隐藏了，在这种情况下 flash 会停止运行，请改用以下方式隐藏，给 需要隐藏的元素加 webuploader-element-invisible 类名代替加 display:none 属性。</p>
<p> .webuploader-element-invisible {<br> position: absolute !important;<br> clip: rect(1px 1px 1px 1px); /<em> IE6, IE7 </em>/clip: rect(1px,1px,1px,1px);}</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML中input和textarea的区别]]></title>
      <url>http://www.zhouhy.me/2016/06/13/HTML%E4%B8%ADinput%E5%92%8Ctextarea%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>在HTML中，有两种方式表达文本框，一个是input元素的单行文本框，一种是textarea的多行文本框。</p>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><ol>
<li>需要通过 指定type的值为text</li>
<li><p>可通过 size 属性指定显示字符的长度，value属性指定初使值，maxlength属性指定文本框可以输入最长长度；</p>
<p> <code>&lt;input type=&quot;text&quot; value=&quot;&quot; size=&quot;10&quot; maxlength=&quot;15&quot; /&gt;</code></p>
</li>
</ol>
<h2 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h2><ol>
<li>需要双标签<code>&lt;textarea&gt;&lt;/textarea&gt;</code></li>
<li>内容放在<code>&lt;textarea&gt;&lt;/textarea&gt;</code>标签中</li>
<li><p>使用row,col指定大小</p>
<p> <code>&lt;textarea row=&quot;3&quot; col=&quot;4&quot;&gt;这里放内容&lt;/textarea&gt;</code></p>
</li>
</ol>
<p>区别：一个是单行文本框，一个是多行文本框。</p>
]]></content>
      
        
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js实现无限层级树形结构（有点类似递归）]]></title>
      <url>http://www.zhouhy.me/2016/05/27/js%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E5%B1%82%E7%BA%A7%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%EF%BC%88%E6%9C%89%E7%82%B9%E7%B1%BB%E4%BC%BC%E9%80%92%E5%BD%92%EF%BC%89/</url>
      <content type="html"><![CDATA[<pre><code>var zNodes=[
    {id:1,pId:0,name:&quot;0A&quot;},
    {id:11,pId:1,name:&quot;1A1&quot;},
    {id:12,pId:1,name:&quot;1A2&quot;},
    {id:13,pId:1,name:&quot;1A3&quot;},
    {id:2,pId:0,name:&quot;0B&quot;},
    {id:21,pId:2,name:&quot;2B1&quot;},
    {id:22,pId:2,name:&quot;2B2&quot;},
    {id:23,pId:2,name:&quot;2B3&quot;},
    {id:3,pId:0,name:&quot;0C&quot;},
    {id:31,pId:3,name:&quot;3C1&quot;},
    {id:32,pId:3,name:&quot;3C2&quot;},
    {id:33,pId:3,name:&quot;3C3&quot;},
    {id:34,pId:31,name:&quot;31x&quot;},
    {id:35,pId:31,name:&quot;31y&quot;},
    {id:36,pId:31,name:&quot;31z&quot;},
    {id:37,pId:36,name:&quot;36z&quot;} ,
    {id:38,pId:37,name:&quot;37z&quot;}
];
function treeMenu(a){
    this.tree=a||[];
    this.groups={};
};
treeMenu.prototype={
init:function(pid){
    this.group();
    return this.getDom(this.groups[pid]);
},
group:function(){
    for(var i=0;i&lt;this.tree.length;i++){
        if(this.groups[this.tree[i].pId]){
            this.groups[this.tree[i].pId].push(this.tree[i]);
        }else{
            this.groups[this.tree[i].pId]=[];
            this.groups[this.tree[i].pId].push(this.tree[i]);
        }
    }
    console.dir(this.groups)
},
getDom:function(a){
    if(!a){return &apos;&apos;}
    var html=&apos;\n&lt;ul &gt;\n&apos;;
    for(var i=0;i&lt;a.length;i++){
        html+=&apos;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&apos;+a[i].name+&apos;&lt;/a&gt;&apos;;
        html+=this.getDom(this.groups[a[i].id]);
        html+=&apos;&lt;/li&gt;\n&apos;;
    };
    html+=&apos;&lt;/ul&gt;\n&apos;;
    return html;
}
};
var html=new treeMenu(zNodes).init(0);
console.log(html);
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
